/*
 * IRIS -- Intelligent Roadway Information System
 * Copyright (C) 2000-2009  Minnesota Department of Transportation
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
package us.mn.state.dot.tms.server.comm.aws;

import java.util.Calendar;
import us.mn.state.dot.sched.Completer;
import us.mn.state.dot.sched.Job;
import us.mn.state.dot.sched.Scheduler;
import us.mn.state.dot.sonar.server.ServerNamespace;
import us.mn.state.dot.tms.CommProtocol;
import us.mn.state.dot.tms.Controller;
import us.mn.state.dot.tms.ControllerHelper;
import us.mn.state.dot.tms.SystemAttrEnum;
import us.mn.state.dot.tms.server.comm.AddressedMessage;
import us.mn.state.dot.tms.server.comm.HttpFileMessenger;
import us.mn.state.dot.tms.server.comm.MessagePoller;
import us.mn.state.dot.tms.server.comm.Messenger;
import us.mn.state.dot.tms.server.ControllerImpl;
import us.mn.state.dot.tms.utils.I18N;
import us.mn.state.dot.tms.utils.Log;
import us.mn.state.dot.tms.utils.STime;

/**
 * AWS poller, which periodically retrieves DMS messages
 * generated by the external AWS system via the specified URL.
 *
 * @author Douglas Lau
 * @author Michael Darter
 */
public class AwsPoller extends MessagePoller
{
	/** Create scheduler that runs AWS activation job */
	static protected final Scheduler m_scheduler =
		new Scheduler("Scheduler: AWS Activation");

	/** the only valid drop address */
	static public final int VALID_DROP_ADDRESS = 1;

	/** server namespace */
	final ServerNamespace m_namespace;

	/** Create a new poller */
	public AwsPoller(String n, Messenger m, ServerNamespace namespace) {
		super(n, m);
		assert m instanceof HttpFileMessenger;
		m_namespace = namespace;

		// add 30 second timer to aws scheduler
		m_scheduler.addJob(new AwsTimerJob());
	}

	/** Create a new message for the specified controller, 
	 *  called by MessagePoller.doPoll(). */
	public AddressedMessage createMessage(ControllerImpl c) {
		// Log.finest("AwsPoller.createMessage() called.");
		return new Message(messenger);
	}

	/** Check if a drop address is valid */
	public boolean isAddressValid(int drop) {
		return (drop == VALID_DROP_ADDRESS);
	}

	/** Return name of AWS system */
	public static String awsName() {
		return I18N.get("dms.aws.abbreviation");
	}

	/** Get the one AWS controller */
	protected ControllerImpl getController() {
		//FIXME: flag error if more than one controller of this type
		return (ControllerImpl)ControllerHelper.getController(
			CommProtocol.AWS);
	}

	/** Return true if the AWS is activated. */
	public static boolean awsActive() {
		return SystemAttrEnum.DMS_AWS_ENABLE.getBoolean();
	}

	/** Get the AWS read time in seconds. This is the number of seconds
	 *  to wait after :00 and :30 to read the AWS messages. */
	public static int getAwsReadTimeSecs() {
		int secs = SystemAttrEnum.DMS_AWS_READ_TIME.getInt();
		secs = (secs < 0 ? 0 : secs);
		secs = (secs > 29 ? 29 : secs);
		return secs;
	}

	/** AWS timer job */
	protected class AwsTimerJob extends Job {

		/** Job completer */
		protected final Completer m_comp;

		/** Current time stamp */
		protected Calendar stamp;

		/** Job to be performed on completion */
		protected final Job job = new Job() {
			public void perform() {
				// nothing
			}
		};

		/** Create a new 30-second timer job */
		protected AwsTimerJob() {
			super(Calendar.SECOND, 30, Calendar.SECOND, 
				getAwsReadTimeSecs());
			m_comp = new Completer("30-Second", m_scheduler, job);
		}

		/** Perform the 30-second timer job */
		public void perform() throws Exception {
			if(!m_comp.checkComplete())
				return;
			Calendar s = Calendar.getInstance();
			s.add(Calendar.SECOND, -30);
			stamp = s;
			m_comp.reset(stamp);
			try {
				doWork();
			} finally {
				m_comp.makeReady();
			}
		}

		/** do the job work */
		private void doWork() {
			ControllerImpl c = getController();
			if(c == null) {
				Log.config("AWS controller not defined, " +
					"unable to activate AWS messages.");
				return;
			}
			if(awsActive())
				new OpProcessAwsMsgs(c).start();
		}
	}
}
